# 日报

## 任务内容

熟悉iOS的内存管理

- ### 基础概念
1. 对象何时会被释放？
2. weak 与 strong 的区别

- ### 常见的内存泄漏情形

1. [Delegate 模式中的循环引用](Delegate.swift)
2. [Block 中的循环引用](Block.swift)
3. [全局变量，单例模式中的内存泄漏](Singleton.swift)
4. [对象作为局部变量时，如果被类的属性引用](LocalVariable.swift)

## 知识总结

- ### 基础概念
1. 对象 **不** 再被 **强引用** 时释放
2. strong 是强引用，swift中默认强引用；weak 是弱引用

- ### 常见的内存泄漏情形

1. Delegate 模式是一个常见的对象互相持有的情形。设有A,B两个类，B遵循A的代理协议，B的属性引用A对象，A对象的delegate属性引用B。
   当B初始化后设置为nil时，理想情况是没有变量引用B对象，B对象释放进而切断对其属性的引用，进而释放A对象。可是当设置B对象为nil时，
   它并非不再被强引用，在它还未被释放时它内部的属性仍然引用着A对象，A对象的delegate属性仍然引用着B对象，因此B对象无法释放；那么
   B对象的属性对A对象的引用也无法切断，A对象无法被释放而它的delegate属性对B对象的引用也无法切断。这就构成了循环引用，两个对象互相引用
   着形成了一个闭环，谁也无法释放进而打破闭环使所有人都被释放

   把delegate属性设置为weak可以解决这一问题

2. Block 中的循环引用和 Delegate 模式相似，类的属性引用block，当block内部调用self相关的属性、方法时，为了保证block执行上下文的完整，
   block会对类强引用，接着构成循环引用

   在block中使用[weak self]可以解决这一问题

3. 全局变量对对象的引用需要手动切断，单例模式事实上也是一个全局静态变量。单例模式一经构造不会随便释放，如果内部属性引用对象，那么需要手动切断
   单例内部属性对对象的引用，否则对象永久被单例属性引用不会释放

4. 对象作为局部变量时，在函数执行完毕后会自动释放；如果被类的属性引用，那么当类被释放的时候才会切断对对象的引用才会释放对象
